using UnityEngine;
using UnityEngine.InputSystem;
using static UnityEditor.Experimental.GraphView.GraphView;
using static UnityEditor.Timeline.TimelinePlaybackControls;

namespace LHE
{
    [RequireComponent(typeof(Rigidbody2D))]
    [RequireComponent(typeof(Collider2D))]
    public class PlayerController : MonoBehaviour
    {
        [Header("이동")]
        [SerializeField] public float moveSpeed = 5f;
        [SerializeField] public float acceleration = 50f;
        [SerializeField] public float deceleration = 30f;

        private float currentSpeed;
        private bool facingRight = true;

        [Header("점프")]
        [SerializeField] public float jumpForce = 5f;

        [Header("대쉬")]
        [SerializeField] public float dashForce = 50f;           // 대쉬 시작 속도 (최고속도)
        [SerializeField] public float dashDuration = 0.2f;       // 대쉬 지속 시간
        [SerializeField] public float dashCooldown = 1f;         // 대쉬 쿨다운
        [SerializeField] public float dashEndSpeedRatio = 0.2f;  // 대쉬 종료 시 속도 비율 (0~1)


        [Header("그라운드 체크")]
        public Transform groundCheck;
        public Vector2 groundCheckBoxSize = new Vector2(0.5f, 0.1f);
        public LayerMask groundLayerMask = 1 << 9;

        // 컨트롤 (카운터 등)
        private float jumpBufferCounter;

        // 인풋
        private Vector2 moveInput;
        private bool jumpInput;
        private bool jumpInputDown;

        private bool dashInputDown;
        private Vector2 dashDirection;

        // 중복 방지
        private float jumpBufferTime = 0.2f; // 점프 버퍼

        // 컴포넌트
        private Rigidbody2D rb;
        private Collider2D col;

        // 점프용
        private bool isGrounded;
        private bool wasGrounded;

        // 대쉬용
        private bool isDashing;
        private float dashCooldownLeft;
        private float dashTimeLeft;
        private float dashProgress;


        #region 유니티 주기
        void Awake()
        {
            rb = GetComponent<Rigidbody2D>();
            col = GetComponent<Collider2D>();
        }

        void Update()
        {
            CheckGrounded();
            HandleTimers();
        }

        void FixedUpdate()
        {
            
            Movement();
            HandleJump();
            HandleDash();
        }
        #endregion

        #region 인풋
        public void OnMove(InputValue inputValue)
        {
            moveInput = inputValue.Get<Vector2>();
        }
        
        public void OnJump(InputValue inputValue)
        {
            if (inputValue.isPressed)
            {
                jumpInputDown = true;
                jumpBufferCounter = jumpBufferTime;
            }
        }

        public void OnDash(InputValue inputValue)
        {
            if (inputValue.isPressed)
            {
                dashInputDown = true;
            }
        }
        #endregion

        #region 체크 및 타이머
        /// <summary>
        /// 땅에 있는지 체크
        /// </summary>
        void CheckGrounded()
        {
            isGrounded = Physics2D.OverlapBox(groundCheck.position, groundCheckBoxSize, 0f, groundLayerMask);
        }

        /// <summary>
        /// 조작키 중복을 방지하기 위한 타이머 및 쿨타임
        /// </summary>
        void HandleTimers()
        {
            if (jumpBufferCounter > 0)
            {
                jumpBufferCounter -= Time.deltaTime;
            }

            if (dashCooldownLeft > 0)
            {
                dashCooldownLeft -= Time.deltaTime;
            }
        }
        #endregion

        #region 이동
        /// <summary>
        /// 이동을 위한 물리력 가함
        /// </summary>
        void Movement()
        {
            float targetSpeed = moveInput.x * moveSpeed;

            // 사다리 오르는 중일 경우 타겟 스피드 속도 조절하여 위 아래로만 적용

            // 가속도 감속도 조절
            float accelRate = (Mathf.Abs(targetSpeed) > 0.01f) ? acceleration : deceleration;
            currentSpeed = Mathf.MoveTowards(currentSpeed, targetSpeed, accelRate * Time.fixedDeltaTime);

            rb.velocity = new Vector2(currentSpeed, rb.velocity.y);

            // 방향키 방향에 따라 바라보기 
            if (moveInput.x > 0 && !facingRight)
            {
                Flip();
            }
            else if (moveInput.x < 0 && facingRight)
            {
                Flip();
            }
        }

        /// <summary>
        /// 케릭터 보는 방향 뒤집기
        /// </summary>
        void Flip()
        {
            facingRight = !facingRight;
            transform.Rotate(0, 180, 0);
        }
        #endregion

        #region 점프
        /// <summary>
        /// 점프 가능한 조건 확인
        /// </summary>
        void HandleJump()
        {
            if (jumpInputDown && jumpBufferCounter > 0f && isGrounded) 
            {
                Jump();
            }
        }

        /// <summary>
        /// 점프를 위한 물리력 가함
        /// </summary>
        void Jump()
        {
            rb.velocity = new Vector2(rb.velocity.x, jumpForce);

            // 점프 상태 업데이트
            jumpInputDown = false; // 점프 입력 소모
            jumpBufferCounter = 0f; // 점프 버퍼 소모

            Debug.Log("점프 실행!");
        }

        #endregion

        #region 대쉬
        void HandleDash()
        {
            
            if (dashInputDown && dashCooldownLeft <= 0f && !isDashing)
            {
                StartDash();
            }

            if (isDashing)
            {
                UpdateDash();
                dashTimeLeft -= Time.fixedDeltaTime;

                if (dashTimeLeft <= 0f)
                {
                    EndDash();
                }
                else
                {
                    rb.velocity = dashDirection * dashForce;
                }
            }
        }

        /// <summary>
        /// 대쉬 시작
        /// </summary>
        void StartDash()
        {
            isDashing = true;
            dashTimeLeft = dashDuration;
            dashCooldownLeft = dashCooldown;

            // 대쉬 방향 결정 (바라보는 방향)
            dashDirection = new Vector2(facingRight ? 1 : -1, 0);

            // 무적 시작 하는 메서드 추가
        }

        /// <summary>
        /// 대쉬 진행 업데이트
        /// </summary>
        void UpdateDash()
        {
            dashTimeLeft -= Time.fixedDeltaTime;

            // 대쉬 진행도 계산 (0~1)
            dashProgress = 1f - (dashTimeLeft / dashDuration);

            if (dashTimeLeft <= 0f)
            {
                EndDash();
            }
            else
            {
                // 시작속도에서 끝속도로 부드럽게 감소
                float speedRatio = Mathf.Lerp(1f, dashEndSpeedRatio, dashProgress);
                Vector2 dashVelocity = dashDirection * dashForce * speedRatio;

                rb.velocity = dashVelocity;
            }
        }

        /// <summary>
        /// 대쉬 종료
        /// </summary>
        void EndDash()
        {
            isDashing = false;
            dashInputDown = false;
            // 대쉬 종료 시 속도 조절 (급정거 방지)
            rb.velocity = rb.velocity * 0.3f;

            Debug.Log("대쉬 종료!");
        }
        #endregion

        #region 디버그용 기즈모
        void OnDrawGizmosSelected()
        {
            // 바닥 감지
            if (groundCheck != null)
            {
                Gizmos.color = isGrounded ? Color.green : Color.red;
                Gizmos.DrawWireCube(groundCheck.position, groundCheckBoxSize);
            }
        }
        #endregion
    }
}

